<?php

/*
 * (c) 2025 Anton Semenov <20430159+trydalcoholic@users.noreply.github.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

namespace Cartwryte\Sleuth\Helper;

use RuntimeException;

/**
 * Path helper methods.
 *
 * Allows reliable joining of path parts, normalizing separators
 * and removing redundant slashes.
 *
 * @package Cartwryte\Sleuth\Helper
 *
 * @author Anton Semenov
 */
final class PathHelper
{
  private static ?string $rootPath = null;

  /**
   * Private constructor to prevent instantiation.
   */
  private function __construct() {}

  /**
   * Gets the root path of the OpenCart installation.
   * It reads from a configuration file generated by the Composer installer.
   *
   * @throws RuntimeException if the config file is not found
   *
   * @return string
   */
  public static function getRoot(): string
  {
    if (!is_null(self::$rootPath)) {
      return self::$rootPath;
    }

    $configFile = dirname(__DIR__) . '/config/paths.php';

    if (!file_exists($configFile)) {
      throw new RuntimeException('Sleuth path config file not found. Please run "composer update" to regenerate it.');
    }

    $config = require $configFile;

    // Add defensive checks to satisfy static analysis and ensure runtime safety.
    if (!is_array($config)
        || !isset($config['opencart_root'])
        || !is_string($config['opencart_root'])
        || $config['opencart_root'] === ''
    ) {
      throw new RuntimeException('Invalid path configuration found in "paths.php". The "opencart_root" key is missing or invalid. Please run "composer update".');
    }

    // Now it's safe to assign and return the value.
    self::$rootPath = $config['opencart_root'];

    return self::$rootPath;
  }

  /**
   * Joins path segments into one, using DIRECTORY_SEPARATOR.
   *
   * @param string ...$segments Path part by part
   *
   * @return string Normalized path
   *
   * @example
   *   PathHelper::join('var', 'www/', '/html', 'index.tpl')
   *   // → 'var/www/html/index.tpl'
   */
  public static function join(string ...$segments): string
  {
    if (empty($segments)) {
      return '';
    }

    // Process all segments to remove leading/trailing slashes from each part.
    $parts = array_map(static fn (string $seg): string => trim($seg, '/\\'), $segments);

    // Filter out any empty parts that might result from trimming (e.g., a segment that was just '/').
    $parts = array_filter($parts, static fn (string $part): bool => $part !== '');

    // Join the clean parts with the correct separator.
    $path = implode(DIRECTORY_SEPARATOR, $parts);

    // If the very first original segment was an absolute path, restore the leading slash.
    if (str_starts_with($segments[0], '/') || str_starts_with($segments[0], '\\')) {
      return DIRECTORY_SEPARATOR . $path;
    }

    return $path;
  }

  /**
   * Normalizes path: replaces all slashes with DIRECTORY_SEPARATOR,
   * and removes double/trailing ones.
   *
   * @param string $path
   *
   * @return string
   *
   * @example
   *   PathHelper::normalize('/var//www/html/')
   *   // → '/var/www/html'
   */
  public static function normalize(string $path): string
  {
    $path = preg_replace('#[\\\/]+#', DIRECTORY_SEPARATOR, $path);

    if (is_null($path)) {
      throw new RuntimeException('Failed to normalize path during slash replacement.');
    }

    return $path;
  }
}
